namespace SafetyFirst
open SafetyFirst.ErrorTypes  
open SafetyFirst.Numbers
open SafetyFirst.FSharpxCopy.Collections


module FiniteSeq =

  /// <summary>
  /// Wraps the two given enumerations as a single concatenated enumeration.
  /// </summary>
  let inline append (FSeq xs : FiniteSeq<_>) (FSeq ys : FiniteSeq<_>) : FiniteSeq<_> = fseq (LazyList.append xs ys)

  /// <summary>
  /// Returns the average of the elements in the sequence.
  /// The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property associated with the element type.
  /// Returns an Error if the input sequence is empty.
  /// </summary>
  let inline averageSafe (xs : FiniteSeq<_>) = 
    if Seq.isEmpty xs 
    then Error <| avgErr ()
    else Ok <| Seq.average xs

  /// <summary>
  /// Returns the average of the elements in the sequence.
  /// The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property associated with the element type.
  /// Returns an Error if the input sequence is empty.
  /// </summary>
  let inline average' xs = averageSafe xs  

  /// <summary>
  /// Returns the average of the results generated by applying the function to each element of the sequence.
  /// The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property associated with the generated type.
  /// Returns an Error if the input sequence is empty.
  /// </summary>
  let inline averageBySafe projection (xs : FiniteSeq<_>) = 
    if Seq.isEmpty xs
    then Error <| avgErr ()
    else Ok <| Seq.averageBy projection xs

  /// <summary>
  /// Returns the average of the results generated by applying the function to each element of the sequence.
  /// The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property associated with the generated type.
  /// Returns an Error if the input sequence is empty.
  /// </summary>
  let inline averageBy' projection xs = averageBySafe projection xs  

  /// <summary>
  /// Applies the given function to each element of the list. Return the list comprised of 
  /// the results "x" for each element where the function returns Some(x).
  /// The returned sequence may be passed between threads safely. 
  /// However, individual IEnumerator values generated from the returned sequence should 
  /// not be accessed concurrently.
  /// </summary>
  let choose chooser (source : FiniteSeq<_>) : FiniteSeq<_> = fseq (Seq.choose chooser source)
    
  /// <summary>
  /// Divides the input sequence into chunks of size at most <c>size</c>.
  /// Returns a NegativeInput Error if the <c>size</c> is less than or equal to zero.
  /// </summary>
  let chunkBySizeSafe size (xs : FiniteSeq<_>) : Result<FiniteSeq<_>, _> =
    if size <= 0 
    then Error chunkErr
    else Seq.chunkBySize size xs |> fseq |> Ok

  /// <summary>
  /// Divides the input sequence into chunks of size at most <c>size</c>.
  /// Returns a NegativeInput Error if the <c>size</c> is less than or equal to zero.
  /// </summary>
  let inline chunkBySize' size xs = chunkBySizeSafe size xs

  /// <summary>
  /// Divides the input sequence into chunks of size at most <c>size</c>.
  /// Same as <c>Seq.chunkBySize</c>, but restricts the input to a PositiveInt
  /// </summary>
  let chunksOf (PositiveInt size) (xs : FiniteSeq<_>) : FiniteSeq<_> = fseq <| Seq.chunkBySize size xs

  /// <summary>
  /// Combines the given enumeration-of-enumerations as a single concatenated enumeration.
  /// </summary>
  let inline concat (FSeq xs : FiniteSeq<FiniteSeq<'a>>) : FiniteSeq<_> = fseq (xs |> LazyList.map (|FSeq|) |> LazyList.concat)

  /// <summary>
  /// Tests if the sequence contains the specified element.
  /// </summary>
  let inline contains element (xs : FiniteSeq<_>) = Seq.contains element xs

  /// <summary>
  /// Applies the given function to each element of the sequence and concatenates all the results.
  /// Returned sequence is lazy, effects are delayed until it is enumerated.
  /// </summary>
  let inline collect (f : 'a -> FiniteSeq<'b>) (FSeq xs : FiniteSeq<'a>) : FiniteSeq<_> = 
    let g = f >> (|FSeq|)
    fseq (xs |> LazyList.map g |> LazyList.concat)

  /// <summary>
  /// O(1). Return a new list which contains the given item followed by the
  /// given list.
  /// </summary>
  let cons head (FSeq xs : FiniteSeq<_>) : FiniteSeq<_> = fseq (LazyList.cons head xs)

  /// <summary>
  /// Applies a key-generating function to each element of a sequence and returns a sequence yielding unique keys and their number of occurrences in the original sequence.
  /// Note that this function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.
  /// </summary>
  let countBy projection (xs : FiniteSeq<_>) : FiniteSeq<_> = fseq <| Seq.countBy projection xs

  /// <summary>
  /// Returns a sequence that contains no duplicate entries according to generic hash and equality comparisons on the entries. If an element occurs multiple times in the sequence then the later occurrences are discarded.
  /// </summary>
  let distinct (xs : FiniteSeq<_>) : FiniteSeq<_> = fseq <| Seq.distinct xs

  /// <summary>
  /// Returns a sequence that contains no duplicate entries according to the generic hash and equality comparisons on the keys returned by the given key-generating function. If an element occurs multiple times in the sequence then the later occurrences are discarded.
  /// </summary>
  let distinctBy projection (xs : FiniteSeq<_>) : FiniteSeq<_> = fseq <| Seq.distinctBy projection xs

  /// <summary>
  /// O(n), where n is count. Return the list which on consumption will remove of at most 'n' elements of
  /// the input list.
  /// </summary>
  let inline drop n (FSeq xs : FiniteSeq<_>) : FiniteSeq<_> = fseq (LazyList.drop n xs)

  /// <summary>
  /// O(n), where n is count. Return the seq which will remove at most 'n' elements of
  /// the input seq.
  /// This function will return the input seq unaltered for negative values of 'n'.
  /// </summary>
  let dropLenient n xs = 
    match n with
    | Natural i -> drop i xs
    | neg -> xs  

  /// <summary>
  /// O(1). Evaluates to the sequence that contains no items
  /// </summary>
  let empty<'a> : FiniteSeq<_> = fseq (LazyList.empty<'a>)

  /// <summary>
  /// Tests if any element of the sequence satisfies the given predicate.
  /// The predicate is applied to the elements of the input sequence. If any application returns true then the overall result is true and no further elements are tested. Otherwise, false is returned.
  /// </summary>
  let inline exists predicate (xs : FiniteSeq<_>) = Seq.exists predicate xs 

  /// <summary>
  /// Applies a function to each element of the collection, threading an accumulator argument
  /// through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c>
  /// then computes <c>f (... (f s i0)...) iN</c>
  /// </summary>
  let inline fold f initialState (FSeq xs : FiniteSeq<_>) = LazyList.fold f initialState xs

  /// <summary>
  /// Applies a function to each element of the collection, starting from the end, threading an accumulator argument through the computation. 
  /// If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes <c>f i0 (... (f iN s)...)</c>
  /// </summary>
  let inline foldBack f (xs : FiniteSeq<_>) initialState = Seq.foldBack f xs initialState

  /// <summary>
  /// Returns a new collection containing only the elements of the collection
  /// for which the given predicate returns "true". This is a synonym for Seq.where.
  /// </summary>
  let inline filter f (FSeq xs : FiniteSeq<_>) : FiniteSeq<_> = fseq (LazyList.filter f xs)

  /// <summary>
  /// Returns the first element for which the given function returns True.
  /// Return None if no such element exists.
  /// </summary>
  let inline tryFind predicate (FSeq xs : FiniteSeq<_>) = LazyList.tryFind predicate xs

  /// <summary>
  /// Returns the last element for which the given function returns True. Return None if no such element exists.
  /// This function digests the whole initial sequence as soon as it is called. This function consumes the whole input sequence before returning the result.
  /// </summary>
  let inline tryFindBack predicate (xs : FiniteSeq<_>) = Seq.tryFindBack predicate xs

  /// <summary>
  /// Returns the index of the first element in the sequence that satisfies the given predicate. Return None if no such element exists.
  /// </summary>
  let inline tryFindIndex predicate (xs : FiniteSeq<_>) = Seq.tryFindIndex predicate xs

  /// <summary>
  /// Returns the index of the last element in the sequence that satisfies the given predicate. Return None if no such element exists
  /// This function digests the whole initial sequence as soon as it is called. This function consumes the whole input sequence before returning the result.
  /// </summary>
  let inline tryFindIndexBack predicate (xs : FiniteSeq<_>) = Seq.tryFindIndexBack predicate xs

  /// <summary>
  /// Returns the first element for which the given function returns True.
  /// Returns a NoMatchingElement Error if no such element is found.
  /// </summary>
  let findSafe predicate xs = 
    tryFind predicate xs |> Result.ofOption findErr
  
  /// <summary>
  /// Returns the first element for which the given function returns True.
  /// Returns a NoMatchingElement Error if no such element is found.
  /// </summary>
  let inline find' predicate xs = findSafe predicate xs

  /// <summary>
  /// Returns the last element for which the given function returns True. Return an Error if no such element exists.
  /// This function digests the whole initial sequence as soon as it is called. 
  /// <summary/>
  let findBackSafe predicate (xs : FiniteSeq<_>) = 
    Seq.tryFindBack predicate xs |> Result.ofOption findErr

  /// <summary>
  /// Returns the last element for which the given function returns True. Return an Error if no such element exists.
  /// This function digests the whole initial sequence as soon as it is called. 
  /// <summary/>
  let inline findBack' predicate xs = findBackSafe predicate xs

  /// <summary>
  /// Returns the index of the first element in the sequence that satisfies the given predicate. Return a NoMatchingElement Error if no such element exists.
  /// </summary>
  let findIndexSafe predicate (xs : FiniteSeq<_>) =
    Seq.tryFindIndex predicate xs |> Result.ofOption findErr

  /// <summary>
  /// Returns the index of the first element in the sequence that satisfies the given predicate. Return a NoMatchingElement Error if no such element exists.
  /// </summary>
  let inline findIndex' predicate (xs : FiniteSeq<_>) = findIndexSafe predicate xs

  /// <summary>
  /// Returns the index of the last element in the sequence that satisfies the given predicate. Return an Error if no such element exists.
  /// This function digests the whole initial sequence as soon as it is called. 
  /// </summary>
  let findIndexBackSafe predicate (xs : FiniteSeq<_>) = 
    Seq.tryFindIndexBack predicate xs |> Result.ofOption findErr

  /// <summary>
  /// Returns the index of the last element in the sequence that satisfies the given predicate. Return an Error if no such element exists.
  /// This function digests the whole initial sequence as soon as it is called. 
  /// </summary>
  let inline findIndexBack' predicate xs = findIndexBackSafe predicate xs

  /// <summary>
  /// Tests if all elements of the sequence satisfy the given predicate.
  /// The predicate is applied to the elements of the input sequence. If any application returns false then the overall result is false and no further elements are tested. Otherwise, true is returned.
  /// </summary>
  let inline forall predicate (xs : FiniteSeq<_>) = Seq.forall predicate xs 

  /// <summary>
  /// Applies a key-generating function to each element of a sequence and yields a sequence of unique keys. Each unique key contains a sequence of all elements that match to this key.
  /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.  
  /// </summary>
  let inline groupBy projection (xs : FiniteSeq<_>) : FiniteSeq<(_ * FiniteSeq<_>)> = 
    Seq.groupBy projection xs |> Seq.map (fun (key, value) -> (key, fseq value)) |> fseq

  /// <summary>
  /// Returns the first element of the sequence.
  /// </summary>
  let tryHead (FSeq xs : FiniteSeq<_>) = LazyList.head xs

  /// <summary>
  /// Returns the first element of the sequence.
  /// </summary>
  let headSafe xs = tryHead xs |> Result.ofOption headErr

  /// <summary>
  /// Returns the first element of the sequence.
  /// </summary>
  let inline head' xs = headSafe xs

  /// <summary>
  /// Builds a new collection whose elements are the corresponding elements of the input collection paired with the integer index (from 0) of each element.
  /// </summary>
  let indexed (xs : FiniteSeq<_>) : FiniteSeq<_> = fseq (Seq.indexed xs)

  /// <summary>
  /// Generates a new sequence which, when iterated, will return successive elements by calling the given function, up to the given count.
  /// Same as <c>Seq.init</c>, but restricts <c>count</c> to a NaturalInt, and provides NaturalInt indices to <c>initializer</c>.
  /// </summary>
  let initN count initializer = fseq (LazyList.initN count initializer)

  /// <summary>
  /// Generates a new sequence which, when iterated, will return successive elements by calling the given function, up to the given count.
  /// Returns a NegativeInput Error when <c>count</c> is not natural.
  /// </summary>
  let initSafe count initializer =
    match count with
    | NonNatural _ -> Error <| initErr count
    | Natural count -> Ok <| initN count initializer

  /// <summary>
  /// Generates a new sequence which, when iterated, will return successive elements by calling the given function, up to the given count.
  /// Returns a NegativeInput Error when <c>count</c> is not natural.
  /// </summary>
  let inline init' count initializer = initSafe count initializer

  /// <summary>
  /// Returns true if the sequence contains no elements, false otherwise.
  /// </summary>
  let inline isEmpty (FSeq xs : FiniteSeq<_>) = LazyList.isEmpty xs

  /// <summary>
  /// Applies the given function to each element of the collection.
  /// </summary>
  let inline iter action (xs : FiniteSeq<_>) = Seq.iter action xs

  /// <summary>
  /// Applies the given function to each element of the collection. The integer passed to the function indicates the index of element.
  /// </summary>
  let inline iteri action (xs : FiniteSeq<_>) = Seq.iteri action xs
  
  /// <summary>
  /// Returns the last element of the sequence. Return an Error if no such element exists.
  /// </summary>
  let lastSafe (xs : FiniteSeq<_>) = Seq.tryLast xs |> Option.toResult lastErr

  /// <summary>
  /// Returns the last element of the sequence. Return an Error if no such element exists.
  /// </summary>
  let inline last' xs = lastSafe xs

  /// <summary>
  /// Returns the last element of the sequence. Return None if no such element exists.
  /// </summary>
  let inline tryLast (xs : FiniteSeq<_>) = Seq.tryLast xs 

  /// <summary>
  /// Returns the length of the sequence
  /// </summary>
  let inline length (xs : FiniteSeq<_>) = xs.Length

  /// <summary>
  /// Builds a new collection whose elements are the results of applying the given function
  /// to each of the elements of the collection. The given function will be applied
  /// as elements are demanded using the MoveNext method on enumerators retrieved from the
  /// object.
  /// </summary>
  let inline map f (FSeq xs : FiniteSeq<_>) : FiniteSeq<_> = fseq (LazyList.map f xs)
  
  /// <summary>
  /// Builds a new collection whose elements are the results of applying the given function
  /// to each of the elements of the collection. The integer index passed to the
  /// function indicates the index (from 0) of element being transformed.
  /// </summary>
  let mapi f (FSeq xs : FiniteSeq<_>) : FiniteSeq<_> =
    fseq (LazyList.map2 f (LazyList.ofSeq (Seq.initInfinite id)) xs)

  /// <summary>
  /// O(1). Build a new collection whose elements are the results of applying the given function
  /// to the corresponding elements of the two collections pairwise.  The two sequences need not have equal lengths:
  /// when one sequence is exhausted any remaining elements in the other sequence are ignored.
  /// </summary>
  let inline map2 f (FSeq xs : FiniteSeq<_>) (FSeq ys : FiniteSeq<_>) : FiniteSeq<_> = 
    fseq (LazyList.map2 f xs ys)

  /// <summary>
  /// O(1). Build a new collection whose elements are the results of applying the given function
  /// to the corresponding elements of the two collections pairwise.  
  /// Returns a DifferingLengths Error if the sequences are different lengths.
  /// </summary>
  let map2Safe f xs ys =
    if length xs <> length ys 
    then Error (map2Err (length xs) (length ys)) 
    else Ok (map2 f xs ys)

  /// <summary>
  /// O(1). Build a new collection whose elements are the results of applying the given function
  /// to the corresponding elements of the two collections pairwise.  
  /// Returns a DifferingLengths Error if the sequences are different lengths.
  /// </summary>
  let inline map2' f xs ys = map2Safe f xs ys

  /// <summary>
  /// O(1). Build a new collection whose elements are the results of applying the given function
  /// to the corresponding elements of the two collections pairwise.  
  /// Returns None if the sequences are different lengths.
  /// </summary>
  let tryMap2 f xs ys = map2' f xs ys |> Result.toOption

  /// <summary>
  /// Combines map and fold. Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection. The function is also used to accumulate a final value.
  /// This function digests the whole initial sequence as soon as it is called. This function consumes the whole input sequence before yielding the first element of the result sequence.
  /// </summary>
  let inline mapFold mapping initialState (xs : FiniteSeq<_>) : (FiniteSeq<_> * _) = 
    let (accumulator, result) = Seq.mapFold mapping initialState xs
    in (fseq accumulator, result)

  /// <summary>
  /// Combines map and foldBack. Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection. The function is also used to accumulate a final value.
  /// This function digests the whole initial sequence as soon as it is called. This function consumes the whole input sequence before yielding the first element of the result sequence.
  /// </summary>
  let inline mapFoldBack mapping (xs : FiniteSeq<_>) initialState : (FiniteSeq<_> * _) = 
    let (accumulator, result) = Seq.mapFoldBack mapping xs initialState
    in (fseq accumulator, result)

  /// <summary>
  /// Returns the greatest of all elements of the sequence, compared via Operators.max.
  /// Returns an Error if the sequence is empty.
  /// </summary>
  let maxSafe<'a when 'a : comparison> (xs : FiniteSeq<'a>) = 
    if Seq.isEmpty xs 
    then Error maxErr
    else Ok <| Seq.max xs

  /// <summary>
  /// Returns the greatest of all elements of the sequence, compared via Operators.max.
  /// Returns an Error if the sequence is empty.
  /// </summary>
  let inline max'<'a when 'a : comparison> (xs : FiniteSeq<'a>) = maxSafe xs

  /// <summary>
  /// Returns the greatest of all elements of the sequence, compared via Operators.max on the function result.
  /// Returns an Error if the sequence is empty.
  /// </summary>
  let maxBySafe<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs : FiniteSeq<'a>) = 
    if Seq.isEmpty xs 
    then Error maxErr
    else Ok <| Seq.maxBy projection xs

  /// <summary>
  /// Returns the greatest of all elements of the sequence, compared via Operators.max on the function result.
  /// Returns an Error if the sequence is empty.
  /// </summary>
  let inline maxBy'<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs : FiniteSeq<'a>) = maxBySafe projection xs

  /// <summary>
  /// Returns the lowest of all elements of the sequence, compared via Operators.min.
  /// Returns an Error if the sequence is empty.
  /// </summary>
  let minSafe<'a when 'a : comparison> (xs : FiniteSeq<'a>) = 
    if Seq.isEmpty xs 
    then Error minErr
    else Ok <| Seq.min xs

  /// <summary>
  /// Returns the lowest of all elements of the sequence, compared via Operators.min.
  /// Returns an Error if the sequence is empty.
  /// </summary>
  let inline min'<'a when 'a : comparison> (xs : FiniteSeq<'a>) = minSafe xs

  /// <summary>
  /// Returns the lowest of all elements of the sequence, compared via Operators.min on the function result.
  /// Returns an Error if the sequence is empty.
  /// </summary>
  let minBySafe<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs : FiniteSeq<'a>) = 
    if Seq.isEmpty xs 
    then Error minErr
    else Ok <| Seq.minBy projection xs

  /// <summary>
  /// Returns the lowest of all elements of the sequence, compared via Operators.min on the function result.
  /// Returns an Error if the sequence is empty.
  /// </summary>
  let inline minBy'<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs : FiniteSeq<'a>) = minBySafe projection xs

  /// <summary>
  /// Views the given array as a finite sequence.
  /// </summary>
  let inline ofArray xs : FiniteSeq<_> = fseq (LazyList.ofArray xs)
  
  /// <summary>
  /// Views the given seq as a finite sequence.  There is no runtime validation
  /// that the seq is actually finite, so this is a programmer assertion that the
  /// seq will be finite.
  /// </summary>
  let inline ofSeq xs : FiniteSeq<_> = fseq (LazyList.ofSeq xs) 

  /// <summary>
  /// Views the given list as a finite sequence.  
  /// </summary>
  let inline ofList xs : FiniteSeq<_> = fseq (LazyList.ofList xs)

  /// <summary>
  /// Returns a sequence of each element in the input sequence and its predecessor, with the
  /// exception of the first element which is only returned as the predecessor of the second element.
  /// </summary>
  let pairwise (FSeq xs : FiniteSeq<_>) : FiniteSeq<_> = fseq (Seq.pairwise xs)

  /// <summary>
  /// Applies a function to each element of the sequence, threading an accumulator argument
  /// through the computation. Begin by applying the function to the first two elements.
  /// Then feed this result into the function along with the third element and so on.
  /// Return the final result.  
  /// If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes <c>f (f (...(f i0 i1)) iN-1) iN</c>.
  /// Returns a SeqIsEmpty Error if the sequence is empty.
  /// </summary>
  let reduceSafe f (FSeq xs : FiniteSeq<_>) = 
    match LazyList.uncons xs with
    | Some (head, tail) -> Ok <| LazyList.fold f head tail
    | None -> Error reduceErr

  /// <summary>
  /// Applies a function to each element of the sequence, threading an accumulator argument
  /// through the computation. Begin by applying the function to the first two elements.
  /// Then feed this result into the function along with the third element and so on.
  /// Return the final result.  
  /// If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes <c>f (f (...(f i0 i1)) iN-1) iN</c>.
  /// Returns a SeqIsEmpty Error if the sequence is empty.
  /// </summary>
  let inline reduce' f xs = reduceSafe f xs   

  /// <summary>
  /// Applies a function to each element of the sequence, threading an accumulator argument
  /// through the computation. Begin by applying the function to the first two elements.
  /// Then feed this result into the function along with the third element and so on.
  /// Return the final result.  
  /// If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes <c>f (f (...(f i0 i1)) iN-1) iN</c>.
  /// Returns None if the sequence is empty
  /// </summary>
  let tryReduce f xs = reduce' f xs |> Result.toOption

  /// <summary>
  /// Applies a function to each element of the sequence, starting from the end, threading an accumulator argument through the computation. 
  /// If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes <c>f i0 (...(f iN-1 iN))</c>.
  /// This function consumes the whole input sequence before returning the result.
  /// Returns a SeqIsEmpty Error if the sequence is empty.
  /// </summary>
  let reduceBackSafe f (xs : FiniteSeq<_>) = 
    if Seq.isEmpty xs
    then Error reduceErr
    else Ok <| Seq.reduceBack f xs

  /// <summary>
  /// Applies a function to each element of the sequence, starting from the end, threading an accumulator argument through the computation. 
  /// If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes <c>f i0 (...(f iN-1 iN))</c>.
  /// This function consumes the whole input sequence before returning the result.
  /// Returns a SeqIsEmpty Error if the sequence is empty.
  /// </summary>
  let inline reduceBack' f xs = reduceBackSafe f xs

  /// <summary>
  /// Generates a new sequence which, when iterated, will return the given value for every element, up to the given count.
  /// Same as <c>Seq.replicate</c>, but restricts <c>count</c> to a NaturalInt.
  /// </summary>
  let replicateN (count:NaturalInt) initial = fseq (LazyList.replicateN count initial)

  /// <summary>
  /// Generates a new sequence which, when iterated, will return the given value for every element, up to the given count.
  /// Returns a NegativeInput Error when <c>count</c> is not natural.
  /// </summary>
  let replicateSafe count initial =
    match count with
    | NonNatural _ -> Error <| replicateErr count
    | Natural count -> Ok <| replicateN count initial

  /// <summary>
  /// Generates a new sequence which, when iterated, will return the given value for every element, up to the given count.
  /// Returns a NegativeInput Error when <c>count</c> is not natural.
  /// </summary>
  let inline replicate' count initial = replicateSafe count initial

  /// <summary>
  /// Returns a new sequence with the elements in reverse order.
  /// </summary>
  let inline rev (FSeq xs : FiniteSeq<_>) : FiniteSeq<_> = fseq (LazyList.rev xs)

  /// <summary>
  /// Like fold, but computes on-demand and returns the sequence of intermediary and final results.
  /// </summary>
  let inline scan f initialState (FSeq xs : FiniteSeq<_>) : FiniteSeq<_> = fseq (LazyList.scan f initialState xs)

  /// <summary>
  /// Like foldBack, but returns the sequence of intermediary and final results.
  /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. 
  /// This function consumes the whole input sequence before yielding the first element of the result sequence.
  /// </summary>
  let inline scanBack f (xs : FiniteSeq<_>) initialState : FiniteSeq<_> = fseq (Seq.scanBack f xs initialState)

  /// <summary>
  /// Yields a sequence ordered by keys.
  /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.
  /// This is a stable sort, that is the original order of equal elements is preserved. This function consumes the whole input sequence before yielding the first element of the result sequence.
  /// </summary>
  let inline sort (xs : FiniteSeq<_>) : FiniteSeq<_> = fseq (Seq.sort xs)

  /// <summary>
  /// Applies a key-generating function to each element of a sequence and yield a sequence ordered by keys. The keys are compared using generic comparison as implemented by <c>Operators.compare</c>.
  /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.
  /// This is a stable sort, that is the original order of equal elements is preserved.
  /// </summary>
  let inline sortBy projection (xs : FiniteSeq<_>) : FiniteSeq<_> = fseq (Seq.sortBy projection xs)

  /// <summary>
  /// Yields a sequence ordered descending by keys.
  /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.
  /// This is a stable sort, that is the original order of equal elements is preserved.
  /// </summary>
  let inline sortDescending (xs : FiniteSeq<_>) : FiniteSeq<_> = fseq (Seq.sortDescending xs)

  /// <summary>
  /// Applies a key-generating function to each element of a sequence and yield a sequence ordered descending by keys. The keys are compared using generic comparison as implemented by <c>Operators.compare</c>.
  /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.
  /// This is a stable sort, that is the original order of equal elements is preserved.
  /// </summary>
  let inline sortByDescending projection (xs : FiniteSeq<_>) : FiniteSeq<_> = fseq (Seq.sortByDescending projection xs)

  /// <summary>
  /// Yields a sequence ordered using the given comparison function.
  /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.
  /// This is a stable sort, that is the original order of equal elements is preserved. This function consumes the whole input sequence before yielding the first element of the result sequence.
  /// </summary>
  let inline sortWith comparer (xs : FiniteSeq<_>) : FiniteSeq<_> = fseq (Seq.sortWith comparer xs)

  /// <summary>
  /// O(n), where n is count. Return the list which skips the first 'n' elements of
  /// the input list.
  /// </summary>
  let trySkip n (FSeq xs : FiniteSeq<_>) : Option<FiniteSeq<_>> = Option.map fseq (LazyList.skip n xs)

  /// <summary>
  /// O(n), where n is count. Return the list which skips the first 'n' elements of
  /// the input list.
  /// </summary>
  let skipSafe n xs = 
    trySkip n xs 
    |> Result.ofOptionWith (fun () -> skipErr n (length xs))
    
  /// <summary>
  /// O(n), where n is count. Return the list which skips the first 'n' elements of
  /// the input list.
  /// </summary>
  let inline skip' n xs = skipSafe n xs  

  /// <summary>
  /// Returns a sequence that skips at least N elements of the underlying sequence and then yields the
  /// remaining elements of the sequence.
  /// Returns an empty sequence if <c>count</c> exceeds the length of <c>xs</c> 
  /// </summary>
  let skipLenient count xs = 
    skip' count xs 
    |> Result.defaultValue (fseq [])
  
  /// <summary>
  /// Returns a sequence that, when iterated, skips elements of the underlying sequence while the
  /// given predicate returns True, and then yields the remaining elements of the sequence.
  /// </summary>
  let skipWhile predicate (FSeq xs : FiniteSeq<_>) : FiniteSeq<_> = 
    fseq (Seq.skipWhile predicate xs)

  /// <summary>
  /// Splits the input sequence into at most <c>count</c> chunks.
  /// This function consumes the whole input sequence before yielding the first element of the result sequence.
  /// </summary>
  let splitIntoN (PositiveInt n) (xs : FiniteSeq<_>) : FiniteSeq<FiniteSeq<_>> = Seq.splitInto n xs |> Seq.map fseq |> fseq

  /// <summary>
  /// Splits the input sequence into at most <c>count</c> chunks.
  /// This function consumes the whole input sequence before yielding the first element of the result sequence.
  /// Returns an Error if <c>count</c> is zero or negative.
  /// </summary>
  let splitIntoSafe n xs = 
    match n with
    | Positive p -> Ok <| splitIntoN p xs
    | _ -> Error <| splitIntoErr n

  /// <summary>
  /// Splits the input sequence into at most <c>count</c> chunks.
  /// This function consumes the whole input sequence before yielding the first element of the result sequence.
  /// Returns an Error if <c>count</c> is zero or negative.
  /// </summary>
  let inline splitInto' n xs = splitIntoSafe n xs

  /// <summary>
  /// Returns the sum of the elements in the sequence.
  /// The elements are summed using the <c>+</c> operator and <c>Zero</c> property associated with the generated type.
  /// </summary>
  let inline sum (xs : FiniteSeq<_>) = Seq.sum xs

  /// <summary>
  /// Returns the sum of the results generated by applying the function to each element of the sequence.
  /// The elements are summed using the <c>+</c> operator and <c>Zero</c> property associated with the generated type.
  /// </summary>
  let inline sumBy projection (xs : FiniteSeq<_>) = Seq.sumBy projection xs

  /// <summary>
  /// O(1). Return option the list corresponding to the remaining items in the sequence.
  /// Forces the evaluation of the first cell of the list if it is not already evaluated.
  /// </summary>
  let tryTail (FSeq xs : FiniteSeq<_>) : Option<FiniteSeq<_>> = Option.map fseq (LazyList.tail xs)
  
  /// <summary>
  /// O(1). Return option the list corresponding to the remaining items in the sequence.
  /// Forces the evaluation of the first cell of the list if it is not already evaluated.
  /// </summary>
  let tailSafe xs  = tryTail xs |> Result.ofOption tailErr

  /// <summary>
  /// O(1). Return option the list corresponding to the remaining items in the sequence.
  /// Forces the evaluation of the first cell of the list if it is not already evaluated.
  /// </summary>
  let inline tail' xs = tailSafe xs

  /// <summary>
  /// O(n), where n is count. Return the list which on consumption will consist of exactly 'n' elements of
  /// the input list.
  /// </summary>
  let tryTake n (FSeq xs : FiniteSeq<_>) : Option<FiniteSeq<_>> = Option.map fseq (LazyList.take n xs)

  /// <summary>
  /// O(n), where n is count. Return the list which on consumption will consist of exactly 'n' elements of
  /// the input list.
  /// </summary>
  let takeSafe n xs = 
    tryTake n xs 
    |> Result.ofOptionWith (fun () -> takeErr n (length xs))

  /// <summary>
  /// O(n), where n is count. Return the list which on consumption will consist of exactly 'n' elements of
  /// the input list.
  /// </summary>
  let inline take' n xs = takeSafe n xs 

  /// <summary>
  /// Returns a sequence that, when iterated, yields elements of the underlying sequence while the
  /// given predicate returns True, and then returns no further elements.
  /// </summary>
  let takeWhile predicate (FSeq xs : FiniteSeq<_>) : FiniteSeq<_> =
    fseq (Seq.takeWhile predicate xs)

  /// <summary>
  /// Builds an array from the given collection.
  /// </summary>
  let inline toArray (FSeq xs : FiniteSeq<_>) = LazyList.toArray xs

  /// <summary>
  /// Builds a List from the given collection.
  /// </summary>
  let inline toList (FSeq xs : FiniteSeq<_>) = LazyList.toList xs
  
  /// <summary>
  /// Views the given FiniteSeq as a sequence.
  /// </summary>
  let inline toSeq (FSeq xs : FiniteSeq<_>) : _ seq = upcast xs

  /// <summary>
  /// Returns the transpose of the given sequence of sequences.
  /// This function works with non-square inputs by just skipping over
  /// any sublists that aren't long enough.
  /// </summary>
  let transpose (xs : seq<FiniteSeq<_>>) : FiniteSeq<FiniteSeq<_>> = Seq.transpose xs |> Seq.map fseq |> fseq

  /// <summary>
  /// Returns the transpose of the given sequence of sequences. Returns a DifferingLengths Error if
  /// the input sequences differ in length. 
  /// </summary>
  let transposeSafe (xs : seq<FiniteSeq<_>>) : Result<FiniteSeq<FiniteSeq<_>>, _> = 
    match xs with 
    | SeqOneOrMore (head, tail) -> 
      let headLength = length head
      if Seq.forall (length >> (=) headLength) tail
      then Ok (Seq.transpose xs |> Seq.map fseq |> fseq)
      else Error transposeErr
    | _ -> Ok empty

  /// <summary>
  /// Returns the transpose of the given sequence of sequences. Returns a DifferingLengths Error if
  /// the input sequences differ in length. 
  /// </summary>
  let inline transpose' xs = transposeSafe xs

  /// <summary>
  /// Returns a sequence that when enumerated returns at most N elements.
  /// </summary>
  let truncate n (FSeq xs : FiniteSeq<_>) : FiniteSeq<_> = fseq (LazyList.ofSeq (Seq.truncate n xs))  

  /// <summary>
  /// O(1). Returns tuple of head element and tail of the list.
  /// </summary>
  let unconsSafe (FSeq xs : FiniteSeq<_>) : Result<(_ * FiniteSeq<_>), _> =
    match LazyList.uncons xs with
    | Some (head, tail) -> Ok (head, fseq tail)
    | None -> Error unconsErr

  /// <summary>
  /// O(1). Returns tuple of head element and tail of the list.
  /// </summary>
  let inline uncons' xs = unconsSafe xs

  /// <summary>
  /// O(1). Returns tuple of head element and tail of the list.
  /// </summary>
  let tryUncons xs = uncons' xs |> Result.toOption 

  /// <summary>
  /// Returns a sequence that yields sliding windows containing elements drawn from the input sequence. Each window is returned as a fresh fseq.
  /// Same as Seq.windowed but takes the size in as a <c>PositiveInt</c>.
  /// </summary>
  let inline window (PositiveInt size) (xs : FiniteSeq<_>) : FiniteSeq<FiniteSeq<_>> = fseq (Seq.windowed size xs |> Seq.map fseq)

  /// <summary>
  /// Returns a sequence that yields sliding windows containing elements drawn from the input sequence. Each window is returned as a fresh fseq.
  /// Returns a NegativeInput Error if the size is zero or negative.
  /// </summary>
  let windowedSafe size xs = 
    match size with
    | Positive p -> Ok <| window p xs
    | _ -> Error <| windowedErr size

  /// <summary>
  /// Returns a sequence that yields sliding windows containing elements drawn from the input sequence. Each window is returned as a fresh fseq.
  /// Returns a NegativeInput Error if the size is zero or negative.
  /// </summary>
  let inline windowed' size xs = windowedSafe size xs

  /// <summary>
  /// Combines the two sequences into a list of pairs. The two sequences need not have equal lengths:
  /// when one sequence is exhausted any remaining elements in the other
  /// sequence are ignored.
  /// </summary>
  let inline zip (FSeq xs : FiniteSeq<_>) (FSeq ys : FiniteSeq<_>) : FiniteSeq<_> = fseq (LazyList.zip xs ys)

  /// <summary>
  /// Combines the two sequences into a list of pairs. 
  /// Returns a DifferingLengths Error if the sequences are different lengths.
  /// </summary>
  let zipSafe xs ys =
    if length xs <> length ys 
    then Error (zipErr (length xs) (length ys)) 
    else Ok (zip xs ys)

  /// <summary>
  /// Combines the two sequences into a list of pairs. 
  /// Returns a DifferingLengths Error if the sequences are different lengths.
  /// </summary>
  let inline zip' xs ys = zipSafe xs ys  

  /// <summary>
  /// Combines the two sequences into a list of pairs. 
  /// Returns None if the sequences are different lengths.
  /// </summary>
  let tryZip xs ys = zipSafe xs ys |> Result.toOption

  /// <summary>
  /// Combines the three sequences into a list of triples.  The three sequences need not have equal lengths:
  /// when one sequence is exhausted any remaining elements in the other sequences are ignored.
  /// </summary>
  let inline zip3 (xs : FiniteSeq<_>) (ys : FiniteSeq<_>) (zs : FiniteSeq<_>) : FiniteSeq<_> = fseq (Seq.zip3 xs ys zs)

  /// <summary>
  /// Combines the three sequences into a list of triples. 
  /// Returns a DifferingLengths Error if the sequences are different lengths.
  /// </summary>
  let zip3Safe xs ys zs =
    if length xs <> length ys || length xs <> length zs
    then Error (zip3Err (length xs) (length ys) (length zs)) 
    else Ok (zip3 xs ys zs)

  /// <summary>
  /// Combines the three sequences into a list of triples. 
  /// Returns a DifferingLengths Error if the sequences are different lengths.
  /// </summary>
  let inline zip3' xs ys zs = zip3Safe xs ys zs 

  /// <summary>
  /// Combines the three sequences into a list of triples. 
  /// Returns None if the sequences are different lengths.
  /// </summary>
  let tryZip3 xs ys zs = zip3Safe xs ys zs |> Result.toOption

module FSeq =
  /// <summary>
  /// Returns the average of the elements in the sequence.
  /// The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property associated with the element type.
  /// Returns an Error if the input sequence is empty.
  /// </summary>
  let inline averageSafe (xs : _ fseq) = FiniteSeq.averageSafe xs

  /// <summary>
  /// Returns the average of the elements in the sequence.
  /// The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property associated with the element type.
  /// Returns an Error if the input sequence is empty.
  /// </summary>
  let inline average' (xs : _ fseq) = FiniteSeq.average' xs

  /// <summary>
  /// Returns the average of the results generated by applying the function to each element of the sequence.
  /// The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property associated with the generated type.
  /// Returns an Error if the input sequence is empty.
  /// </summary>
  let inline averageBySafe projection (xs : _ fseq) = FiniteSeq.averageBySafe projection xs

  /// <summary>
  /// Returns the average of the results generated by applying the function to each element of the sequence.
  /// The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property associated with the generated type.
  /// Returns an Error if the input sequence is empty.
  /// </summary>
  let inline averageBy' projection xs = averageBySafe projection xs

  /// <summary>
  /// Returns the length of the sequence
  /// </summary>
  let inline length (xs : _ fseq) = FiniteSeq.length xs

  /// <summary>
  /// Applies a function to each element of the collection, threading an accumulator argument
  /// through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c>
  /// then computes <c>f (... (f s i0)...) iN</c>
  /// </summary>
  let inline fold f initialState (xs : _ fseq) = FiniteSeq.fold f initialState xs

  /// <summary>
  /// Applies a function to each element of the collection, starting from the end, threading an accumulator argument through the computation. 
  /// If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes <c>f i0 (... (f iN s)...)</c>
  /// </summary>
  let inline foldBack f (xs : _ fseq) initialState = Seq.foldBack f xs initialState

  /// <summary>
  /// Returns true if the sequence contains no elements, false otherwise.
  /// </summary>
  let inline isEmpty (xs : _ fseq) = FiniteSeq.isEmpty xs
  
  /// <summary>
  /// Returns the last element of the sequence. Return an Error if no such element exists.
  /// </summary>
  let inline lastSafe (xs : _ fseq) = FiniteSeq.lastSafe xs

  /// <summary>
  /// Returns the last element of the sequence. Return an Error if no such element exists.
  /// </summary>
  let inline last' xs = lastSafe xs

  /// <summary>
  /// Returns the last element of the sequence. Return None if no such element exists.
  /// </summary>
  let inline tryLast (xs : _ fseq) = Seq.tryLast xs 

  /// <summary>
  /// Applies a function to each element of the sequence, threading an accumulator argument
  /// through the computation. Begin by applying the function to the first two elements.
  /// Then feed this result into the function along with the third element and so on.
  /// Return the final result.  
  /// Returns a SeqIsEmpty Error if the sequence is empty.
  /// </summary>
  let inline reduceSafe f (xs : _ fseq) = FiniteSeq.reduceSafe f xs

  /// <summary>
  /// Applies a function to each element of the sequence, threading an accumulator argument
  /// through the computation. Begin by applying the function to the first two elements.
  /// Then feed this result into the function along with the third element and so on.
  /// Return the final result.  
  /// Returns a SeqIsEmpty Error if the sequence is empty.
  /// </summary>
  let inline reduce' f xs = reduceSafe f xs

  /// <summary>
  /// Applies a function to each element of the sequence, threading an accumulator argument
  /// through the computation. Begin by applying the function to the first two elements.
  /// Then feed this result into the function along with the third element and so on.
  /// Return the final result.  
  /// Returns None if the sequence is empty
  /// </summary>
  let inline tryReduce f (xs : _ fseq) = FiniteSeq.tryReduce f xs

  /// <summary>
  /// Applies a function to each element of the sequence, starting from the end, threading an accumulator argument through the computation. 
  /// If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes <c>f i0 (...(f iN-1 iN))</c>.
  /// This function consumes the whole input sequence before returning the result.
  /// Returns a SeqIsEmpty Error if the sequence is empty.
  /// </summary>
  let inline reduceBackSafe f (xs : _ fseq) = FiniteSeq.reduceBackSafe f xs

  /// <summary>
  /// Applies a function to each element of the sequence, starting from the end, threading an accumulator argument through the computation. 
  /// If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes <c>f i0 (...(f iN-1 iN))</c>.
  /// This function consumes the whole input sequence before returning the result.
  /// Returns a SeqIsEmpty Error if the sequence is empty.
  /// </summary>
  let inline reduceBack' f xs = reduceBackSafe f xs

  /// <summary>
  /// Builds a new collection whose elements are the results of applying the given function
  /// to each of the elements of the collection. The given function will be applied
  /// as elements are demanded using the MoveNext method on enumerators retrieved from the
  /// object.
  /// </summary>
  let inline map f (xs : _ fseq) : _ fseq = FiniteSeq.map f xs

  /// <summary>
  /// Builds a new collection whose elements are the results of applying the given function
  /// to each of the elements of the collection. The integer index passed to the
  /// function indicates the index (from 0) of element being transformed.
  /// </summary>
  let inline mapi f (xs : _ fseq) : _ fseq = FiniteSeq.mapi f xs

  /// <summary>
  /// O(1). Build a new collection whose elements are the results of applying the given function
  /// to the corresponding elements of the two collections pairwise. The two sequences need not have equal lengths:
  /// when one sequence is exhausted any remaining elements in the other sequence are ignored.
  /// </summary>
  let inline map2 f (xs : _ fseq) (ys : _ fseq) : _ fseq = FiniteSeq.map2 f xs ys

  /// <summary>
  /// Returns a new collection containing only the elements of the collection
  /// for which the given predicate returns "true". This is a synonym for Seq.where.
  /// </summary>
  let inline filter f (xs : _ fseq) : _ fseq = FiniteSeq.filter f xs

  /// <summary>
  /// Wraps the two given enumerations as a single concatenated enumeration.
  /// </summary>
  let inline append (xs : _ fseq) (ys : _ fseq) : _ fseq = FiniteSeq.append xs ys

  /// <summary>
  /// Applies the given function to each element of the list. Return the list comprised of 
  /// the results "x" for each element where the function returns Some(x).
  /// The returned sequence may be passed between threads safely. 
  /// However, individual IEnumerator values generated from the returned sequence should 
  /// not be accessed concurrently.
  /// </summary>
  let inline choose chooser (source : _ fseq) : _ fseq = FiniteSeq.choose chooser source
    
  /// <summary>
  /// Divides the input sequence into chunks of size at most <c>size</c>.
  /// Returns a NegativeInput Error if the <c>size</c> is less than or equal to zero.
  /// </summary>
  let inline chunkBySizeSafe size (xs : _ fseq) : Result<_ fseq, _> = FiniteSeq.chunkBySizeSafe size xs

  /// <summary>
  /// Divides the input sequence into chunks of size at most <c>size</c>.
  /// Returns a NegativeInput Error if the <c>size</c> is less than or equal to zero.
  /// </summary>
  let inline chunkBySize' size xs : Result<_ fseq, _> = chunkBySizeSafe size xs

  /// <summary>
  /// Divides the input sequence into chunks of size at most <c>size</c>.
  /// Same as <c>Seq.chunkBySize</c>, but restricts the input to a PositiveInt
  /// </summary>
  let chunksOf (PositiveInt size) (xs : _ fseq) : _ fseq = fseq <| Seq.chunkBySize size xs

  /// <summary>
  /// Combines the given enumeration-of-enumerations as a single concatenated enumeration.
  /// </summary>
  let inline concat (xs : _ fseq fseq) : _ fseq = FiniteSeq.concat xs

  /// <summary>
  /// Tests if the sequence contains the specified element.
  /// </summary>
  let contains element (xs : _ fseq) = Seq.contains element xs

  /// <summary>
  /// Applies a key-generating function to each element of a sequence and returns a sequence yielding unique keys and their number of occurrences in the original sequence.
  /// Note that this function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.
  /// </summary>
  let countBy projection (xs : _ fseq) : _ fseq = FiniteSeq.countBy projection xs

  /// <summary>
  /// Applies the given function to each element of the sequence and concatenates all the results.
  /// Returned sequence is lazy, effects are delayed until it is enumerated.
  /// </summary>
  let inline collect (f : _ -> _ fseq) (xs : _ fseq) : _ fseq = FiniteSeq.collect f xs

  /// <summary>
  /// O(1). Return a new list which contains the given item followed by the
  /// given list.
  /// </summary>
  let inline cons head (xs : _ fseq) : _ fseq = FiniteSeq.cons head xs

  /// <summary>
  /// Returns a sequence that contains no duplicate entries according to generic hash and equality comparisons on the entries. If an element occurs multiple times in the sequence then the later occurrences are discarded.
  /// </summary>
  let distinct (xs : _ fseq) : _ fseq = fseq <| Seq.distinct xs

  /// <summary>
  /// Returns a sequence that contains no duplicate entries according to the generic hash and equality comparisons on the keys returned by the given key-generating function. If an element occurs multiple times in the sequence then the later occurrences are discarded.
  /// </summary>
  let distinctBy projection (xs : _ fseq) : _ fseq = fseq <| Seq.distinctBy projection xs

  /// <summary>
  /// O(n), where n is count. Return the list which on consumption will remove of at most 'n' elements of
  /// the input list.
  /// </summary>
  let inline drop n (xs : _ fseq) : _ fseq = FiniteSeq.drop n xs

  /// <summary>
  /// O(n), where n is count. Return the seq which will remove at most 'n' elements of
  /// the input seq.
  /// This function will return the input seq unaltered for negative values of 'n'.
  /// </summary>
  let inline dropLenient n (xs : _ fseq) : _ fseq = FiniteSeq.dropLenient n xs

  /// <summary>
  /// O(1). Evaluates to the sequence that contains no items
  /// </summary>
  let inline empty<'a when 'a : comparison> : _ fseq = FiniteSeq.empty<'a>

  /// <summary>
  /// Tests if any element of the sequence satisfies the given predicate.
  /// The predicate is applied to the elements of the input sequence. If any application returns true then the overall result is true and no further elements are tested. Otherwise, false is returned.
  /// </summary>
  let inline exists predicate (xs : _ fseq) = Seq.exists predicate xs 

  /// <summary>
  /// Views the given array as a finite sequence.
  /// </summary>
  let inline ofArray xs : _ fseq = FiniteSeq.ofArray xs

  /// <summary>
  /// Views the given seq as a finite sequence.  There is no runtime validation
  /// that the seq is actually finite, so this is a programmer assertion that the
  /// seq will be finite.
  /// </summary>
  let inline ofSeq xs : _ fseq = FiniteSeq.ofSeq xs 

  /// <summary>
  /// Views the given list as a finite sequence.  
  /// </summary>
  let inline ofList xs : _ fseq = FiniteSeq.ofList xs

  /// <summary>
  /// Returns a sequence of each element in the input sequence and its predecessor, with the
  /// exception of the first element which is only returned as the predecessor of the second element.
  /// </summary>
  let inline pairwise xs : _ fseq = FiniteSeq.pairwise xs
  
  /// <summary>
  /// Generates a new sequence which, when iterated, will return the given value for every element, up to the given count.
  /// Same as <c>Seq.replicate</c>, but restricts <c>count</c> to a NaturalInt.
  /// </summary>
  let inline replicateN count initial = FiniteSeq.replicateN count initial

  /// <summary>
  /// Generates a new sequence which, when iterated, will return the given value for every element, up to the given count.
  /// Returns a NegativeInput Error when <c>count</c> is not natural.
  /// </summary>
  let inline replicateSafe count initial = FiniteSeq.replicateSafe count initial

  /// <summary>
  /// Generates a new sequence which, when iterated, will return the given value for every element, up to the given count.
  /// Returns a NegativeInput Error when <c>count</c> is not natural.
  /// </summary>
  let inline replicate' count initial = replicateSafe count initial

  /// <summary>
  /// Returns a new sequence with the elements in reverse order.
  /// </summary>
  let inline rev (xs : _ fseq) : _ fseq = FiniteSeq.rev xs

  /// <summary>
  /// Like fold, but computes on-demand and returns the sequence of intermediary and final results.
  /// </summary>
  let inline scan f initialState (xs : _ fseq) : _ fseq = FiniteSeq.scan f initialState xs

  /// <summary>
  /// Like foldBack, but returns the sequence of intermediary and final results.
  /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. 
  /// This function consumes the whole input sequence before yielding the first element of the result sequence.
  /// </summary>
  let inline scanBack f (xs : _ fseq) initialState : _ fseq = fseq (Seq.scanBack f xs initialState)

  /// <summary>
  /// Yields a sequence ordered by keys.
  /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.
  /// This is a stable sort, that is the original order of equal elements is preserved. This function consumes the whole input sequence before yielding the first element of the result sequence.
  /// </summary>
  let inline sort (xs : _ fseq) : _ fseq = fseq (Seq.sort xs)

  /// <summary>
  /// Applies a key-generating function to each element of a sequence and yield a sequence ordered by keys. The keys are compared using generic comparison as implemented by <c>Operators.compare</c>.
  /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.
  /// This is a stable sort, that is the original order of equal elements is preserved.
  /// </summary>
  let inline sortBy projection (xs : _ fseq) : _ fseq = fseq (Seq.sortBy projection xs)

  /// <summary>
  /// Yields a sequence ordered descending by keys.
  /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.
  /// This is a stable sort, that is the original order of equal elements is preserved.
  /// </summary>
  let inline sortDescending (xs : _ fseq) : _ fseq = fseq (Seq.sortDescending xs)

  /// <summary>
  /// Applies a key-generating function to each element of a sequence and yield a sequence ordered descending by keys. The keys are compared using generic comparison as implemented by <c>Operators.compare</c>.
  /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.
  /// This is a stable sort, that is the original order of equal elements is preserved.
  /// </summary>
  let inline sortByDescending projection (xs : _ fseq) : _ fseq = fseq (Seq.sortByDescending projection xs)

  /// <summary>
  /// Yields a sequence ordered using the given comparison function.
  /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.
  /// This is a stable sort, that is the original order of equal elements is preserved. This function consumes the whole input sequence before yielding the first element of the result sequence.
  /// </summary>
  let inline sortWith comparer (xs : _ fseq) : _ fseq = fseq (Seq.sortWith comparer xs)

  /// <summary>
  /// Builds an array from the given collection.
  /// </summary>
  let inline toArray (xs : _ fseq) = FiniteSeq.toArray xs

  /// <summary>
  /// Builds a List from the given collection.
  /// </summary>
  let inline toList (xs : _ fseq) = FiniteSeq.toList xs

  /// <summary>
  /// Views the given FiniteSeq as a sequence.
  /// </summary>
  let inline toSeq (xs : _ fseq) = FiniteSeq.toSeq xs

  /// <summary>
  /// Returns a sequence that when enumerated returns at most N elements.
  /// </summary>
  let inline truncate n (xs : _ fseq) : _ fseq = FiniteSeq.truncate n xs

  /// <summary>
  /// Returns the first element for which the given function returns True.
  /// Return None if no such element exists.
  /// </summary>
  let inline tryFind predicate (xs : _ fseq) = FiniteSeq.tryFind predicate xs

  /// <summary>
  /// Returns the last element for which the given function returns True. Return None if no such element exists.
  /// This function digests the whole initial sequence as soon as it is called. This function consumes the whole input sequence before returning the result.
  /// </summary>
  let inline tryFindBack predicate (xs : _ fseq) = Seq.tryFindBack predicate xs

  /// <summary>
  /// Returns the index of the first element in the sequence that satisfies the given predicate. Return None if no such element exists.
  /// </summary>
  let inline tryFindIndex predicate (xs : _ fseq) = Seq.tryFindIndex predicate xs

  /// <summary>
  /// Returns the index of the last element in the sequence that satisfies the given predicate. Return None if no such element exists
  /// This function digests the whole initial sequence as soon as it is called. This function consumes the whole input sequence before returning the result.
  /// </summary>
  let inline tryFindIndexBack predicate (xs : _ fseq) = Seq.tryFindIndexBack predicate xs

  /// <summary>
  /// Returns the first element for which the given function returns True.
  /// Returns a NoMatchingElement Error if no such element is found.
  /// </summary>
  let inline findSafe predicate (xs : _ fseq) = FiniteSeq.findSafe predicate xs
  
  /// <summary>
  /// Returns the first element for which the given function returns True.
  /// Returns a NoMatchingElement Error if no such element is found.
  /// </summary>
  let inline find' predicate xs = findSafe predicate xs

  /// <summary>
  /// Returns the index of the first element in the sequence that satisfies the given predicate. Return a NoMatchingElement Error if no such element exists.
  /// </summary>
  let inline findIndexSafe predicate (xs : _ fseq) = FiniteSeq.findIndexSafe predicate xs

  /// <summary>
  /// Returns the index of the first element in the sequence that satisfies the given predicate. Return a NoMatchingElement Error if no such element exists.
  /// </summary>
  let inline findIndex' predicate (xs : _ fseq) = FiniteSeq.findIndex' predicate xs

  /// <summary>
  /// Returns the last element for which the given function returns True. Return an Error if no such element exists.
  /// This function digests the whole initial sequence as soon as it is called. 
  /// <summary/>
  let findBackSafe predicate (xs : _ fseq) = FiniteSeq.findBackSafe predicate xs

  /// <summary>
  /// Returns the last element for which the given function returns True. Return an Error if no such element exists.
  /// This function digests the whole initial sequence as soon as it is called. 
  /// <summary/>
  let inline findBack' predicate xs = findBackSafe predicate xs

  /// <summary>
  /// Returns the index of the last element in the sequence that satisfies the given predicate. Return an Error if no such element exists.
  /// This function digests the whole initial sequence as soon as it is called. 
  /// </summary>
  let inline findIndexBackSafe predicate (xs : _ fseq) = FiniteSeq.findIndexBackSafe predicate xs

  /// <summary>
  /// Returns the index of the last element in the sequence that satisfies the given predicate. Return an Error if no such element exists.
  /// This function digests the whole initial sequence as soon as it is called. 
  /// </summary>
  let inline findIndexBack' predicate xs = findIndexBackSafe predicate xs

  /// <summary>
  /// Tests if all elements of the sequence satisfy the given predicate.
  /// The predicate is applied to the elements of the input sequence. If any application returns false then the overall result is false and no further elements are tested. Otherwise, true is returned.
  /// </summary>
  let inline forall predicate (xs : _ fseq) = Seq.forall predicate xs 

  /// <summary>
  /// Applies a key-generating function to each element of a sequence and yields a sequence of unique keys. Each unique key contains a sequence of all elements that match to this key.
  /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.  
  /// </summary>
  let inline groupBy projection (xs : _ fseq) : (_ * _ fseq) fseq = FiniteSeq.groupBy projection xs

  /// <summary>
  /// Returns the first element of the sequence.
  /// </summary>
  let inline tryHead (xs : _ fseq) = FiniteSeq.tryHead xs

  /// <summary>
  /// Returns the first element of the sequence.
  /// </summary>
  let inline headSafe (xs : _ fseq) = FiniteSeq.headSafe xs

  /// <summary>
  /// Returns the first element of the sequence.
  /// </summary>
  let inline head' xs = headSafe xs

  /// <summary>
  /// Builds a new collection whose elements are the corresponding elements of the input collection paired with the integer index (from 0) of each element.
  /// </summary>
  let inline indexed (xs : _ fseq) : _ fseq = FiniteSeq.indexed xs

  /// <summary>
  /// Generates a new sequence which, when iterated, will return successive elements by calling the given function, up to the given count.
  /// Same as <c>Seq.init</c>, but restricts <c>count</c> to a NaturalInt, and provides NaturalInt indices to <c>initializer</c>.
  /// </summary>
  let inline initN count initializer = FiniteSeq.initN count initializer

  /// <summary>
  /// Generates a new sequence which, when iterated, will return successive elements by calling the given function, up to the given count.
  /// Returns a NegativeInput Error when <c>count</c> is not natural.
  /// </summary>
  let inline initSafe count initializer = FiniteSeq.initSafe count initializer

  /// <summary>
  /// Generates a new sequence which, when iterated, will return successive elements by calling the given function, up to the given count.
  /// Returns a NegativeInput Error when <c>count</c> is not natural.
  /// </summary>
  let inline init' count initializer = initSafe count initializer

  /// <summary>
  /// Applies the given function to each element of the collection.
  /// </summary>
  let inline iter action (xs : _ fseq) = Seq.iter action xs

  /// <summary>
  /// Applies the given function to each element of the collection. The integer passed to the function indicates the index of element.
  /// </summary>
  let inline iteri action (xs : _ fseq) = Seq.iteri action xs

  /// <summary>
  /// O(1). Build a new collection whose elements are the results of applying the given function
  /// to the corresponding elements of the two collections pairwise.  
  /// Returns None if the sequences are different lengths
  /// </summary>
  let inline tryMap2 f (xs : _ fseq) (ys : _ fseq) : _ fseq option = FiniteSeq.tryMap2 f xs ys 

  /// <summary>
  /// O(1). Build a new collection whose elements are the results of applying the given function
  /// to the corresponding elements of the two collections pairwise.  
  /// Returns a DifferingLengths Error if the sequences are different lengths.
  /// </summary>
  let inline map2Safe f (xs : _ fseq) (ys : _ fseq) : Result<_ fseq, _> = FiniteSeq.map2Safe f xs ys

  /// <summary>
  /// O(1). Build a new collection whose elements are the results of applying the given function
  /// to the corresponding elements of the two collections pairwise.  
  /// Returns a DifferingLengths Error if the sequences are different lengths.
  /// </summary>
  let inline map2' f xs ys = map2Safe f xs ys

  /// <summary>
  /// Combines map and fold. Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection. The function is also used to accumulate a final value.
  /// This function digests the whole initial sequence as soon as it is called. This function consumes the whole input sequence before yielding the first element of the result sequence.
  /// </summary>
  let inline mapFold mapping initialState (xs : _ fseq) : (_ fseq * _) = 
    let (accumulator, result) = Seq.mapFold mapping initialState xs
    in (fseq accumulator, result)

  /// <summary>
  /// Combines map and foldBack. Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection. The function is also used to accumulate a final value.
  /// This function digests the whole initial sequence as soon as it is called. This function consumes the whole input sequence before yielding the first element of the result sequence.
  /// </summary>
  let inline mapFoldBack mapping (xs : _ fseq) initialState : (_ fseq * _) = 
    let (accumulator, result) = Seq.mapFoldBack mapping xs initialState
    in (fseq accumulator, result)

  /// <summary>
  /// Returns the greatest of all elements of the sequence, compared via Operators.max.
  /// Returns an Error if the sequence is empty.
  /// </summary>
  let inline maxSafe<'a when 'a : comparison> (xs : 'a fseq) = FiniteSeq.maxSafe xs

  /// <summary>
  /// Returns the greatest of all elements of the sequence, compared via Operators.max.
  /// Returns an Error if the sequence is empty.
  /// </summary>
  let inline max'<'a when 'a : comparison> (xs : 'a fseq) = FiniteSeq.max' xs

  /// <summary>
  /// Returns the greatest of all elements of the sequence, compared via Operators.max on the function result.
  /// Returns an Error if the sequence is empty.
  /// </summary>
  let inline maxBySafe<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs : 'a fseq) = FiniteSeq.maxBySafe projection xs

  /// <summary>
  /// Returns the greatest of all elements of the sequence, compared via Operators.max on the function result.
  /// Returns an Error if the sequence is empty.
  /// </summary>
  let inline maxBy'<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs : 'a fseq) = FiniteSeq.maxBy' projection xs

  /// <summary>
  /// Returns the lowest of all elements of the sequence, compared via Operators.min.
  /// Returns an Error if the sequence is empty.
  /// </summary>
  let inline minSafe<'a when 'a : comparison> (xs : 'a fseq) = FiniteSeq.minSafe xs

  /// <summary>
  /// Returns the lowest of all elements of the sequence, compared via Operators.min.
  /// Returns an Error if the sequence is empty.
  /// </summary>
  let inline min'<'a when 'a : comparison> (xs : 'a fseq) = FiniteSeq.min' xs

  /// <summary>
  /// Returns the lowest of all elements of the sequence, compared via Operators.min on the function result.
  /// Returns an Error if the sequence is empty.
  /// </summary>
  let inline minBySafe<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs : 'a fseq) = FiniteSeq.minBySafe projection xs

  /// <summary>
  /// Returns the lowest of all elements of the sequence, compared via Operators.min on the function result.
  /// Returns an Error if the sequence is empty.
  /// </summary>
  let inline minBy'<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs : 'a fseq) = FiniteSeq.minBy' projection xs

  /// <summary>
  /// O(n), where n is count. Return option the list which skips the first 'n' elements of
  /// the input list.
  /// </summary>
  let inline trySkip n (xs : _ fseq) : _ fseq option = FiniteSeq.trySkip n xs

  /// <summary>
  /// O(n), where n is count. Return the list which skips the first 'n' elements of
  /// the input list.
  /// </summary>
  let inline skipSafe n (xs : _ fseq) : Result<_ fseq, _> = FiniteSeq.skipSafe n xs

  /// <summary>
  /// O(n), where n is count. Return the list which skips the first 'n' elements of
  /// the input list.
  /// </summary>
  let inline skip' n xs = skipSafe n xs

  /// <summary>
  /// Returns a sequence that, when iterated, skips elements of the underlying sequence while the
  /// given predicate returns True, and then yields the remaining elements of the sequence.
  /// </summary>
  let inline skipWhile predicate (xs : _ fseq) : _ fseq = FiniteSeq.skipWhile predicate xs

  /// <summary>
  /// Splits the input sequence into at most <c>count</c> chunks.
  /// This function consumes the whole input sequence before yielding the first element of the result sequence.
  /// </summary>
  let inline splitIntoN n (xs : _ fseq) : _ fseq fseq = FiniteSeq.splitIntoN n xs

  /// <summary>
  /// Splits the input sequence into at most <c>count</c> chunks.
  /// This function consumes the whole input sequence before yielding the first element of the result sequence.
  /// Returns an Error if <c>count</c> is zero or negative.
  /// </summary>
  let inline splitIntoSafe n (xs : _ fseq) : Result<_ fseq fseq, _> = FiniteSeq.splitIntoSafe n xs

  /// <summary>
  /// Splits the input sequence into at most <c>count</c> chunks.
  /// This function consumes the whole input sequence before yielding the first element of the result sequence.
  /// Returns an Error if <c>count</c> is zero or negative.
  /// </summary>
  let inline splitInto' n xs = splitIntoSafe n xs

  /// <summary>
  /// Returns the sum of the elements in the sequence.
  /// The elements are summed using the <c>+</c> operator and <c>Zero</c> property associated with the generated type.
  /// </summary>
  let inline sum (xs : _ fseq) = Seq.sum xs

  /// <summary>
  /// Returns the sum of the results generated by applying the function to each element of the sequence.
  /// The elements are summed using the <c>+</c> operator and <c>Zero</c> property associated with the generated type.
  /// </summary>
  let inline sumBy projection (xs : _ fseq) = Seq.sumBy projection xs

  /// <summary>
  /// Returns a sequence that, when iterated, yields elements of the underlying sequence while the
  /// given predicate returns True, and then returns no further elements.
  /// </summary>
  let inline takeWhile predicate (xs : _ fseq) : _ fseq = FiniteSeq.takeWhile predicate xs

  /// <summary>
  /// O(1). Return option the list corresponding to the remaining items in the sequence.
  /// Forces the evaluation of the first cell of the list if it is not already evaluated.
  /// </summary>
  let inline tryTail (xs : _ fseq) : _ fseq option = FiniteSeq.tryTail xs

  /// <summary>
  /// O(1). Return option the list corresponding to the remaining items in the sequence.
  /// Forces the evaluation of the first cell of the list if it is not already evaluated.
  /// </summary>
  let inline tailSafe (xs : _ fseq) : Result<_ fseq, _> = FiniteSeq.tailSafe xs

  /// <summary>
  /// O(1). Return option the list corresponding to the remaining items in the sequence.
  /// Forces the evaluation of the first cell of the list if it is not already evaluated.
  /// </summary>
  let inline tail' xs = tailSafe xs

  /// <summary>
  /// O(n), where n is count. Return the list which on consumption will consist of exactly 'n' elements of
  /// the input list.
  /// </summary>
  let inline tryTake n (xs : _ fseq) : _ fseq option = FiniteSeq.tryTake n xs
    
  /// <summary>
  /// O(n), where n is count. Return the list which on consumption will consist of exactly 'n' elements of
  /// the input list.
  /// </summary>
  let inline takeSafe n (xs : _ fseq) : Result<_ fseq, _> = FiniteSeq.takeSafe n xs
    
  /// <summary>
  /// O(n), where n is count. Return the list which on consumption will consist of exactly 'n' elements of
  /// the input list.
  /// </summary>
  let inline take' n xs = takeSafe n xs

  /// <summary>
  /// Returns the transpose of the given sequence of sequences.
  /// This function works with non-square inputs by just skipping over
  /// any sublists that aren't long enough.
  /// </summary>
  let inline transpose (xs : _ fseq seq) : _ fseq fseq = FiniteSeq.transpose xs

  /// <summary>
  /// Returns the transpose of the given sequence of sequences. Returns a DifferingLengths Error if
  /// the input sequences differ in length. 
  /// </summary>
  let inline transposeSafe (xs : _ fseq seq) : Result<_ fseq fseq, _> = FiniteSeq.transposeSafe xs

  /// <summary>
  /// Returns the transpose of the given sequence of sequences. Returns a DifferingLengths Error if
  /// the input sequences differ in length. 
  /// </summary>
  let inline transpose' xs = transposeSafe xs

  /// <summary>
  /// O(1). Returns tuple of head element and tail of the list.
  /// </summary>
  let inline tryUncons (xs : _ fseq) : (_*_ fseq) option = FiniteSeq.tryUncons xs

  /// <summary>
  /// O(1). Returns tuple of head element and tail of the list.
  /// </summary>
  let inline unconsSafe (xs : _ fseq) : Result<_*_ fseq, _> = FiniteSeq.unconsSafe xs
  
  /// <summary>
  /// O(1). Returns tuple of head element and tail of the list.
  /// </summary>
  let inline uncons' xs = unconsSafe xs

  /// <summary>
  /// Returns a sequence that yields sliding windows containing elements drawn from the input sequence. Each window is returned as a fresh fseq.
  /// Same as Seq.windowed but takes the size in as a <c>PositiveInt</c>.
  /// </summary>
  let inline window size (xs : _ fseq) : _ fseq fseq = FiniteSeq.window size xs

  /// <summary>
  /// Returns a sequence that yields sliding windows containing elements drawn from the input sequence. Each window is returned as a fresh fseq.
  /// Returns a NegativeInput Error if the size is zero or negative.
  /// </summary>
  let inline windowedSafe size (xs : _ fseq) : Result<_ fseq fseq, _> = FiniteSeq.windowedSafe size xs

  /// <summary>
  /// Returns a sequence that yields sliding windows containing elements drawn from the input sequence. Each window is returned as a fresh fseq.
  /// Returns a NegativeInput Error if the size is zero or negative.
  /// </summary>
  let inline windowed' size xs = windowedSafe size xs

  /// <summary>
  /// Combines the two sequences into a list of pairs. 
  /// Returns None if the sequences are different lengths
  /// </summary>
  let inline tryZip (xs : _ fseq) (ys : _ fseq) : _ fseq option = FiniteSeq.tryZip xs ys

  /// <summary>
  /// Combines the two sequences into a list of pairs. 
  /// Returns a DifferingLengths Error if the sequences are different lengths.
  /// </summary>
  let inline zipSafe (xs : _ fseq) (ys : _ fseq) : Result<_ fseq, _> = FiniteSeq.zipSafe xs ys

  /// <summary>
  /// Combines the two sequences into a list of pairs. 
  /// Returns a DifferingLengths Error if the sequences are different lengths.
  /// </summary>
  let inline zip' xs ys = zipSafe xs ys

  /// <summary>
  /// Combines the two sequences into a list of pairs. The two sequences need not have equal lengths:
  /// when one sequence is exhausted any remaining elements in the other
  /// sequence are ignored.
  /// </summary>
  let inline zip (xs : _ fseq) (ys : _ fseq) : _ fseq = FiniteSeq.zip xs ys

  /// <summary>
  /// Combines the three sequences into a list of triples.  The three sequences need not have equal lengths:
  /// when one sequence is exhausted any remaining elements in the other sequences are ignored.
  /// </summary>
  let inline zip3 (xs : _ fseq) (ys : _ fseq) (zs : _ fseq) : _ fseq = FiniteSeq.zip3 xs ys zs

  /// <summary>
  /// Combines the three sequences into a list of triples. 
  /// Returns None if the sequences are different lengths.
  /// </summary>
  let inline tryZip3 (xs : _ fseq) (ys : _ fseq) (zs : _ fseq) : _ fseq option = FiniteSeq.tryZip3 xs ys zs

  /// <summary>
  /// Combines the three sequences into a list of triples. 
  /// Returns a DifferingLengths Error if the sequences are different lengths.
  /// </summary>
  let inline zip3Safe (xs : _ fseq) (ys : _ fseq) (zs : _ fseq) : Result<_ fseq, _> = FiniteSeq.zip3Safe xs ys zs

  /// <summary>
  /// Combines the three sequences into a list of triples. 
  /// Returns a DifferingLengths Error if the sequences are different lengths.
  /// </summary>
  let inline zip3' xs ys zs = zip3Safe xs ys zs

  /// <summary>
  /// Functions for manipulating NonEmpty FSeqs 
  /// </summary>
  module NonEmpty =
    let (|NonEmptyFSeq|) (NonEmpty xs : NonEmptyFSeq<_>) = xs

    /// <summary>
    /// Creates a new NonEmpty FSeq with the provided head and tail.  
    /// The tail is constrained to be finite.  If the tail is infinite,
    /// use Seq.NonEmpty.create instead
    /// </summary>
    let create head tail : NonEmptyFSeq<_> = NonEmpty (cons head tail)

    /// <summary>
    /// Returns a sequence that yields one item only.
    /// </summary>
    let singleton x : NonEmptyFSeq<_> = NonEmpty (fseq [x])

    let private (<!>) f xs = Result.map f xs

    /// <summary>
    /// Returns the average of the elements in the sequence.
    /// The elements are averaged using the <c>+</c> operator, 
    /// <c>DivideByInt</c> method and <c>Zero</c> property associated with the element type.
    /// </summary>
    let inline average (NonEmptyFSeq xs) = Seq.average xs

    /// <summary>
    /// Returns the average of the results generated by applying the function to each element of the sequence.
    /// The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property associated with the generated type.
    /// </summary>
    let inline averageBy projection (NonEmptyFSeq xs) = Seq.averageBy projection xs

    /// <summary>
    /// Returns the first element of the sequence.
    /// </summary>
    let head (NonEmptyFSeq xs) = Seq.head xs
    
    /// <summary>
    /// Returns the lowest of all elements of the sequence, compared via <c>Operators.min</c>.
    /// </summary
    let min (NonEmptyFSeq xs) = Seq.min xs

    /// <summary>
    /// Returns the greatest of all elements of the sequence, compared via <c>Operators.max</c>.
    /// </summary
    let max (NonEmptyFSeq xs) = Seq.max xs

    /// <summary>
    /// Returns the lowest of all elements of the sequence, compared via <c>Operators.min</c> on the function result.
    /// </summary>
    let minBy projection (NonEmptyFSeq xs) = Seq.minBy projection xs

    /// <summary>
    /// Returns the greatest of all elements of the sequence, compared via <c>Operators.max</c> on the function result.
    /// </summary>
    let maxBy projection (NonEmptyFSeq xs) = Seq.maxBy projection xs
    
    /// <summary>
    /// Returns the last element of the sequence.
    /// </summary>
    let last (NonEmptyFSeq xs) = Seq.last xs

    /// <summary>
    /// Returns the sequence after removing the first element.
    /// </summary>
    let tail (NonEmptyFSeq xs) = fseq (Seq.tail xs)

    /// <summary>
    /// Returns the tuple of the sequence's head and tail
    /// </summary>
    let uncons xs = (head xs, tail xs)
    
    /// <summary>
    /// Applies a function to each element of the sequence, threading an accumulator argument
    /// through the computation. Begin by applying the function to the first two elements.
    /// Then feed this result into the function along with the third element and so on.
    /// Return the final result.
    /// If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes <c>f (f (...(f i0 i1)) iN-1) iN</c>.
    /// </summary>
    let reduce f (NonEmptyFSeq xs) = Seq.reduce f xs

    /// <summary>
    /// Applies a function to each element of the sequence, starting from the end, threading an accumulator argument through the computation. 
    /// If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes <c>f i0 (...(f iN-1 iN))</c>.
    /// </summary>
    let reduceBack f (NonEmptyFSeq xs) = Seq.reduceBack f xs

    /// <summary>
    /// Returns the length of the sequence.
    /// </summary>
    let length (NonEmptyFSeq xs) = FiniteSeq.length xs
    
    /// <summary>
    /// Applies a function to each element of the collection, threading an accumulator argument
    /// through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c>
    /// then computes <c>f (... (f s i0)...) iN</c>
    /// </summary>
    let fold f initialState (NonEmptyFSeq xs) = FiniteSeq.fold f initialState xs

    /// <summary>
    /// Applies a function to each element of the collection, starting from the end, threading an accumulator argument through the computation. 
    /// If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes <c>f i0 (... (f iN s)...)</c>
    /// </summary>
    let inline foldBack f (xs : _ fseq) initialState = foldBack f xs initialState

    /// <summary>
    /// Builds a new collection whose elements are the results of applying the given function
    /// to each of the elements of the collection. The given function will be applied
    /// as elements are demanded using the MoveNext method on enumerators retrieved from the
    /// object.
    /// </summary>
    let map f (NonEmptyFSeq xs) : NonEmptyFSeq<_> = NonEmpty (FiniteSeq.map f xs)
    
    /// <summary>
    /// Builds a new collection whose elements are the results of applying the given function
    /// to each of the elements of the collection. The integer index passed to the
    /// function indicates the index (from 0) of element being transformed.
    /// </summary>
    let mapi f (NonEmptyFSeq xs) : NonEmptyFSeq<_> =
      NonEmpty (FiniteSeq.mapi f xs)
    
    /// <summary>
    /// O(1). Build a new collection whose elements are the results of applying the given function
    /// to the corresponding elements of the two collections pairwise.  The two sequences need not have equal lengths:
    /// when one sequence is exhausted any remaining elements in the other sequence are ignored.  
    /// </summary>
    let map2 f (NonEmptyFSeq xs) (NonEmptyFSeq ys) : NonEmptyFSeq<_> =
      NonEmpty (FiniteSeq.map2 f xs ys)

    /// <summary>
    /// Returns a new collection containing only the elements of the collection
    /// for which the given predicate returns "true". This is a synonym for Seq.where.
    /// </summary>
    let filter f (NonEmptyFSeq xs) = filter f xs

    /// <summary>
    /// Wraps the two given enumerations as a single concatenated enumeration.
    /// </summary>
    let appendL (NonEmptyFSeq xs) ys : NonEmptyFSeq<_> = NonEmpty (append xs ys)

    /// <summary>
    /// Wraps the two given enumerations as a single concatenated enumeration.
    /// </summary>
    let appendR xs (NonEmptyFSeq ys) : NonEmptyFSeq<_> = NonEmpty (append xs ys)

    /// <summary>
    /// Wraps the two given enumerations as a single concatenated enumeration.
    /// </summary>
    let append (NonEmptyFSeq xs) (NonEmptyFSeq ys) : NonEmptyFSeq<_> = NonEmpty (FiniteSeq.append xs ys)

    /// <summary>
    /// Combines the given enumeration-of-enumerations as a single concatenated enumeration.
    /// </summary>
    let concat (NonEmptyFSeq xs : NonEmptyFSeq<NonEmptyFSeq<'a>>) : NonEmptyFSeq<_> = 
      NonEmpty (xs |> FiniteSeq.map (fun (NonEmptyFSeq x) -> x) |> FiniteSeq.concat)

    /// <summary>
    /// Tests if the sequence contains the specified element.
    /// </summary>
    let inline contains element (NonEmptyFSeq xs) = contains element xs

    /// <summary>
    /// Applies a key-generating function to each element of a sequence and returns a sequence yielding unique keys and their number of occurrences in the original sequence. 
    /// Note that this function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.
    /// </summary>
    let inline countBy projection (NonEmptyFSeq xs) = countBy projection xs

    /// <summary>
    /// Applies the given function to each element of the sequence and concatenates all the results.
    /// Returned sequence is lazy, effects are delayed until it is enumerated.
    /// </summary>
    let collect (f : 'a -> NonEmptyFSeq<'b>) (NonEmptyFSeq xs : NonEmptyFSeq<'a>) : NonEmptyFSeq<'b> = 
      let g = f >> (|NonEmpty|)
      NonEmpty (collect g xs)

    /// <summary>
    /// Returns a sequence that contains no duplicate entries according to generic hash and equality comparisons on the entries. If an element occurs multiple times in the sequence then the later occurrences are discarded.
    /// </summary>
    let distinct (NonEmptyFSeq xs) : NonEmptyFSeq<_> = NonEmpty <| distinct xs

    /// <summary>
    /// Returns a sequence that contains no duplicate entries according to the generic hash and equality comparisons on the keys returned by the given key-generating function. If an element occurs multiple times in the sequence then the later occurrences are discarded.
    /// </summary>
    let distinctBy projection (NonEmptyFSeq xs) : NonEmptyFSeq<_> = NonEmpty <| distinctBy projection xs

    /// <summary>
    /// O(n), where n is count. Return the list which on consumption will remove of at most 'n' elements of
    /// the input list.
    /// </summary>
    let drop n (NonEmptyFSeq xs) = drop n xs

    /// <summary>
    /// O(n), where n is count. Return the seq which will remove at most 'n' elements of
    /// the input seq.
    /// This function will return the input seq unaltered for negative values of 'n'.
    /// </summary>
    let dropLenient n (NonEmptyFSeq xs) = dropLenient n xs

    /// <summary>
    /// Tests if any element of the sequence satisfies the given predicate. The predicate is applied to the elements of the input sequence. If any application returns true then the overall result is true and no further elements are tested. Otherwise, false is returned.
    /// </summary>
    let inline exists predicate (NonEmptyFSeq xs) = exists predicate xs

    /// <summary>
    /// Returns the first element for which the given function returns True. Returns a NoMatchingElement Error if no such element is found.
    /// </summary>
    let inline findSafe predicate (NonEmptyFSeq xs) = findSafe predicate xs
    
    /// <summary>
    /// Returns the first element for which the given function returns True. Returns a NoMatchingElement Error if no such element is found.
    /// </summary>
    let inline find' predicate xs = findSafe predicate xs 

    /// <summary>
    /// Returns the index of the first element in the sequence that satisfies the given predicate. Return a NoMatchingElement Error if no such element exists.
    /// </summary>
    let inline findIndexSafe predicate (NonEmptyFSeq xs) = findIndexSafe predicate xs

    /// <summary>
    /// Returns the index of the first element in the sequence that satisfies the given predicate. Return a NoMatchingElement Error if no such element exists.
    /// </summary>
    let inline findIndex' predicate xs = findIndexSafe predicate xs

    /// <summary>
    /// Returns the last element for which the given function returns True. Return an Error if no such element exists. This function digests the whole initial sequence as soon as it is called.
    /// </summary>
    let inline findBackSafe predicate (NonEmptyFSeq xs) = findBackSafe predicate xs

    /// <summary>
    /// Returns the last element for which the given function returns True. Return an Error if no such element exists. This function digests the whole initial sequence as soon as it is called.
    /// </summary>
    let inline findBack' predicate xs = findBackSafe predicate xs

    /// <summary>
    /// Returns the index of the last element in the sequence that satisfies the given predicate. Return an Error if no such element exists. This function digests the whole initial sequence as soon as it is called.
    /// </summary>
    let inline findIndexBackSafe predicate (NonEmptyFSeq xs) = findIndexBackSafe predicate xs

    /// <summary>
    /// Returns the index of the last element in the sequence that satisfies the given predicate. Return an Error if no such element exists. This function digests the whole initial sequence as soon as it is called.
    /// </summary>
    let inline findIndexBack' predicate xs = findIndexBackSafe predicate xs

    /// <summary>
    /// Tests if all elements of the sequence satisfy the given predicate.
    /// The predicate is applied to the elements of the input sequence. If any application returns false then the overall result is false and no further elements are tested. Otherwise, true is returned.
    /// </summary>
    let inline forall predicate (NonEmptyFSeq xs) = forall predicate xs 

    /// <summary>
    /// Applies a key-generating function to each element of a sequence and yields a sequence of unique keys. Each unique key contains a sequence of all elements that match to this key.
    /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.  
    /// </summary>
    let inline groupBy projection (NonEmptyFSeq xs) = groupBy projection xs

    /// <summary>
    /// Builds a new collection whose elements are the corresponding elements of the input collection paired with the integer index (from 0) of each element.
    /// </summary>
    let indexed (NonEmptyFSeq xs) : NonEmptyFSeq<_> = NonEmpty (indexed xs)

    /// <summary>
    /// Generates a new sequence which, when iterated, will return successive elements by calling the given function, up to the given count.
    /// Same as <c>Seq.init</c>, but restricts <c>count</c> to a PositiveInt, and provides NaturalInt indices to <c>initializer</c>.
    /// </summary>
    let initN (count:PositiveInt) initializer = create (initializer NaturalInt.zero) (initN count.Decrement (NaturalInt.increment >> PositiveInt.asNatural >> initializer))

    /// <summary>
    /// Asserts that <c>xs</c> is not empty, creating a NonEmpty FSeq.
    /// Returns a SeqIsEmpty Error if <c>xs</c> is empty.
    /// </summary>
    let ofFSeqSafe (xs:_ fseq) : Result<NonEmptyFSeq<_>,_> = 
      match xs with
      | Empty -> Error <| SeqIsEmpty "Assertion that a sequence is not empty failed."
      | NotEmpty ys -> Ok <| ys

    /// <summary>
    /// Asserts that <c>xs</c> is not empty, creating a NonEmpty FSeq.
    /// Returns a SeqIsEmpty Error if <c>xs</c> is empty.
    /// </summary>
    let inline ofFSeq' xs = ofFSeqSafe xs

    /// <summary>
    /// Returns a sequence of each element in the input sequence and its predecessor, with the
    /// exception of the first element which is only returned as the predecessor of the second element.
    /// </summary>
    let pairwise (NonEmptyFSeq xs) = pairwise xs

    /// <summary>
    /// Generates a new sequence which, when iterated, will return the given value for every element, up to the given count.
    /// Same as <c>Seq.replicate</c>, but restricts <c>count</c> to a PositiveInt.
    /// </summary>
    let replicateN (count:PositiveInt) initial = create initial (replicateN count.Decrement initial)

    /// <summary>
    /// Returns a new sequence with the elements in reverse order.
    /// </summary>
    let rev (NonEmptyFSeq xs) : NonEmptyFSeq<_> = NonEmpty (FiniteSeq.rev xs)

    /// <summary>
    /// Like fold, but computes on-demand and returns the sequence of intermediary and final results.
    /// </summary>
    let scan f initialState (NonEmptyFSeq xs) : NonEmptyFSeq<_> = NonEmpty (FiniteSeq.scan f initialState xs)

    /// <summary>
    /// Yields a sequence ordered by keys.
    /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.
    /// This is a stable sort, that is the original order of equal elements is preserved. This function consumes the whole input sequence before yielding the first element of the result sequence.
    /// </summary>
    let sort (NonEmptyFSeq xs) : NonEmptyFSeq<_> = NonEmpty (sort xs)

    /// <summary>
    /// Applies a key-generating function to each element of a sequence and yield a sequence ordered by keys. The keys are compared using generic comparison as implemented by <c>Operators.compare</c>.
    /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. The function makes no assumption on the ordering of the original sequence.
    /// This is a stable sort, that is the original order of equal elements is preserved.
    /// </summary>
    let sortBy projection (NonEmptyFSeq xs) : NonEmptyFSeq<_> = NonEmpty (sortBy projection xs)

    /// <summary>
    /// Yields a sequence ordered descending by keys. 
    /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. 
    /// The function makes no assumption on the ordering of the original sequence. This is a stable sort, that is the original order of equal elements is preserved.
    /// </summary>
    let sortDescending (NonEmptyFSeq xs) : NonEmptyFSeq<_> = NonEmpty (sortDescending xs)

    /// <summary>
    /// Applies a key-generating function to each element of a sequence and yield a sequence ordered descending by keys. The keys are compared using generic comparison as implemented by <c>Operators.compare</c>. 
    /// This function returns a sequence that digests the whole initial sequence as soon as that sequence is iterated. 
    /// The function makes no assumption on the ordering of the original sequence. This is a stable sort, that is the original order of equal elements is preserved.
    /// </summary>
    let sortByDescending projection (NonEmptyFSeq xs) : NonEmptyFSeq<_> = NonEmpty (sortByDescending projection xs)

    /// <summary>
    /// Builds an array from the given collection.
    /// </summary>
    let toArray (NonEmptyFSeq xs) = FiniteSeq.toArray xs

    /// <summary>
    /// Builds a NonEmpty array from the given collection.
    /// </summary>
    let toNonEmptyArray xs : NonEmptyArray<_> = NonEmpty <| toArray xs

    /// <summary>
    /// Builds a List from the given collection.
    /// </summary>
    let toList (NonEmptyFSeq xs) = FiniteSeq.toList xs

    /// <summary>
    /// Builds a NonEmpty List from the given collection.
    /// </summary>
    let toNonEmptyList xs : NonEmptyList<_> = NonEmpty <| toList xs

    /// <summary>
    /// Views the given NonEmpty FSeq as a sequence.
    /// </summary>
    let toSeq (NonEmptyFSeq xs) : _ seq = upcast xs 

    /// <summary>
    /// Builds a NonEmpty FSeq from the given NonEmpty Seq
    /// </summary>
    let ofNonEmptySeq (NonEmpty xs) : NonEmptyFSeq<_> = NonEmpty (fseq xs)

    /// <summary>
    /// Views the given NonEmpty FSeq as a NonEmpty Seq
    /// </summary>
    let toNonEmptySeq xs : NonEmptySeq<_> = NonEmpty <| toSeq xs

    /// <summary>
    /// Views the given NonEmpty FSeq as an FSeq.
    /// </summary>
    let toFSeq (NonEmptyFSeq xs) = xs

    /// <summary>
    /// Returns the transpose of the given sequence of sequences.
    /// This function works with non-square inputs by just skipping over
    /// any sublists that aren't long enough.
    /// </summary>
    let transpose (NonEmpty xs : NonEmptySeq<NonEmptyFSeq<'a>>) : NonEmptyFSeq<NonEmptyFSeq<'a>> = 
      transpose (xs |> Seq.map (|NonEmpty|))
      |> FiniteSeq.map NonEmpty 
      |> NonEmpty

    /// <summary>
    /// Returns the transpose of the given sequence of sequences. Returns a DifferingLengths Error if
    /// the input sequences differ in length. 
    /// </summary>
    let transposeSafe (NonEmpty xs : NonEmptySeq<NonEmptyFSeq<'a>>) : Result< NonEmptyFSeq<NonEmptyFSeq<'a>> , DifferingLengths> = 
      transposeSafe (xs |> Seq.map (|NonEmpty|))
      |> Result.map (FiniteSeq.map NonEmpty >> NonEmpty)

    /// <summary>
    /// Returns the transpose of the given sequence of sequences. Returns a DifferingLengths Error if
    /// the input sequences differ in length. 
    /// </summary>
    let inline transpose' xs = transposeSafe xs    

    /// <summary>
    /// Returns a sequence that when enumerated returns at most n elements.
    /// </summary>
    let truncate (PositiveInt n) (NonEmpty xs) : NonEmptyFSeq<_> = 
      NonEmpty (truncate n xs)

    /// <summary>
    /// Returns the first element for which the given function returns True.
    /// Return None if no such element exists.
    /// </summary>
    let inline tryFind predicate (NonEmptyFSeq xs) = FiniteSeq.tryFind predicate xs

    /// <summary>
    /// Returns the index of the first element in the sequence that satisfies the given predicate. Return None if no such element exists.
    /// </summary>
    let inline tryFindIndex predicate (NonEmptyFSeq xs) = FiniteSeq.tryFindIndex predicate xs

    /// <summary>
    /// Returns the last element for which the given function returns True. Return None if no such element exists. This function digests the whole initial sequence as soon as it is called. This function consumes the whole input sequence before returning the result.
    /// </summary>    
    let inline tryFindBack predicate (NonEmptyFSeq xs) = FiniteSeq.tryFindBack predicate xs

    /// <summary>
    /// Returns the index of the last element in the sequence that satisfies the given predicate. Return None if no such element exists This function digests the whole initial sequence as soon as it is called. This function consumes the whole input sequence before returning the result.
    /// </summary>
    let inline tryFindIndexBack predicate (NonEmptyFSeq xs) = FiniteSeq.tryFindIndexBack predicate xs

    /// <summary>
    /// O(n), where n is count. Return option the list which skips the first 'n' elements of
    /// the input list.
    /// </summary>
    let trySkip n (NonEmptyFSeq xs) = trySkip n xs

    /// <summary>
    /// O(n), where n is count. Return the list which on consumption will consist of exactly 'n' elements of
    /// the input list.
    /// </summary>
    let tryTake n (NonEmptyFSeq xs) = tryTake n xs

    /// <summary>
    /// Returns a sequence that yields sliding windows containing elements drawn from the input sequence. Each window is returned as a fresh fseq.
    /// Same as Seq.windowed but takes the size in as a <c>PositiveInt</c>.
    /// </summary>
    let inline window n (NonEmptyFSeq xs) = window n xs 

    /// <summary>
    /// Returns a sequence that yields sliding windows containing elements drawn from the input sequence. Each window is returned as a fresh fseq.
    /// Returns a NegativeInput Error if the size is zero or negative.
    /// </summary>
    let inline windowedSafe n (NonEmptyFSeq xs) = windowedSafe n xs

    /// <summary>
    /// Returns a sequence that yields sliding windows containing elements drawn from the input sequence. Each window is returned as a fresh fseq.
    /// Returns a NegativeInput Error if the size is zero or negative.
    /// </summary>
    let inline windowed' n (NonEmptyFSeq xs) = windowed' n xs

    /// <summary>
    /// Combines the two sequences into a list of pairs. 
    /// Returns None if the sequences are different lengths
    /// </summary>
    let tryZip (NonEmptyFSeq xs) (NonEmptyFSeq ys) : Option<NonEmptyFSeq<_>> = Option.map NonEmpty (FiniteSeq.tryZip xs ys)

    /// <summary>
    /// Combines the two sequences into a list of pairs. The two sequences need not have equal lengths:
    /// when one sequence is exhausted any remaining elements in the other
    /// sequence are ignored.
    /// </summary>
    let zip (NonEmptyFSeq xs) (NonEmptyFSeq ys) : NonEmptyFSeq<_> = NonEmpty (FiniteSeq.zip xs ys)

    /// <summary>
    /// Combines the two sequences into a list of pairs. 
    /// Returns a DifferingLengths Error if the sequences are different lengths.
    /// </summary>
    let zipSafe (NonEmptyFSeq xs) (NonEmptyFSeq ys) : Result<NonEmptyFSeq<_>,_> = 
      NonEmpty <!> FiniteSeq.zipSafe xs ys

    /// <summary>
    /// Combines the two sequences into a list of pairs. 
    /// Returns a DifferingLengths Error if the sequences are different lengths.
    /// </summary>
    let inline zip' xs ys = zipSafe xs ys

    /// <summary>
    /// Combines the three sequences into a list of triples.  The three sequences need not have equal lengths:
    /// when one sequence is exhausted any remaining elements in the other sequences are ignored.
    /// </summary>
    let zip3 (NonEmptyFSeq xs) (NonEmptyFSeq ys) (NonEmptyFSeq zs) : NonEmptyFSeq<_> = 
      NonEmpty (FiniteSeq.zip3 xs ys zs)
    
    /// <summary>
    /// Combines the three sequences into a list of triples. 
    /// Returns None if the sequences are different lengths.
    /// </summary>
    let tryZip3 (NonEmptyFSeq xs) (NonEmptyFSeq ys) (NonEmptyFSeq zs) : Option<NonEmptyFSeq<_>> = 
      Option.map NonEmpty (FiniteSeq.tryZip3 xs ys zs)

    /// <summary>
    /// Combines the three sequences into a list of triples. 
    /// Returns a DifferingLengths Error if the sequences are different lengths.
    /// </summary>
    let zip3Safe (NonEmptyFSeq xs) (NonEmptyFSeq ys) (NonEmptyFSeq zs) : Result<NonEmptyFSeq<_>,_> =
      NonEmpty <!> (FiniteSeq.zip3Safe xs ys zs)

    /// <summary>
    /// Combines the three sequences into a list of triples. 
    /// Returns a DifferingLengths Error if the sequences are different lengths.
    /// </summary>
    let inline zip3' xs ys zs = zip3Safe xs ys zs

    /// <summary>
    /// Splits a sequence at every occurrence of an element satisfying <c>splitAfter</c>.
    /// The split occurs immediately after each element that satisfies <c>splitAfter</c>,
    /// and the element satisfying <c>splitAfter</c> will be included as the last element of 
    /// the sequence preceeding the split.
    /// For example:
    /// <code>
    /// split ((=) 100) (FSeq.NonEmpty.create 1[2;3;100;100;4;100;5;6])
    ///   //returns ([[1;2;3;100];[100];[4;100];[5;6]])
    /// </code>
    /// </summary>
    // this implementation is faster than the version in Seq.NonEmpty, but is unsafe for infinite sequences
    // so this should be the default used for any finite sequence (inculding lists and arrays) 
    let split splitAfter xs = 
      let addToEnd xs x = appendR xs (singleton x)
      let (++) = addToEnd

      let rec split' (input:'a fseq) startNewGroup (currentGroup:NonEmptyFSeq<'a>) (completedGroups:fseq<NonEmptyFSeq<'a>>) =
        match input with
        | NotEmpty input ->
          let (head, tail) = uncons input

          let newCurrentGroup, newCompletedGroups = 
            if not startNewGroup
            then (fseq currentGroup ++ head, completedGroups)
            else (singleton head, fseq (completedGroups ++ currentGroup))

          split' tail (splitAfter head) newCurrentGroup newCompletedGroups

        | Empty ->
          completedGroups ++ currentGroup

      let (head, tail) = uncons xs
      split' tail (splitAfter head) (singleton head) (fseq [])

    /// <summary>
    /// Splits a sequence between each pair of adjacent elements that satisfy <c>splitBetween</c>.
    /// For example:
    /// <code>
    /// splitPairwise (=) (Seq.NonEmpty.create 0[1;1;2;3;4;4;4;5])
    ///   //returns [[0;1];[1;2;3;4];[4];[4;5]]
    /// </code>
    /// </summary>
    // this implementation is faster than the version in Seq.NonEmpty, but is unsafe for infinite sequences
    // so this should be the default used for any finite sequence (inculding lists and arrays) 
    let splitPairwise splitBetween xs : NonEmptyFSeq<NonEmptyFSeq<_>> =
      let (++) = appendR

      let rec split' (input:'a fseq) (previousElement:'a) (currentGroup:NonEmptyFSeq<'a>) (completedGroups:fseq<NonEmptyFSeq<'a>>) =
        match input with
        | Empty -> completedGroups ++ singleton currentGroup
        | NotEmpty input -> 
          let (head, tail) = uncons input
          let newInput = tail
          let newPrev = head
          if splitBetween previousElement head
          then 
            let newGroup = (singleton head)
            let newCompletedGroups = (completedGroups ++ singleton currentGroup) 
            split' newInput newPrev newGroup (fseq newCompletedGroups)
          else 
            let expandedGroup = (fseq currentGroup) ++ singleton head
            split' newInput newPrev expandedGroup completedGroups

      let (head, tail) = uncons xs
      split' tail head (singleton head) (fseq [])

open System.Runtime.CompilerServices

[<Extension>]
module EnumerableExtensions = 
  /// <summary>
  /// Creates a FiniteSeq, or a lazy sequence constrained to be finite in length.  There is no possible runtime check
  /// for whether or not an IEnumerable is infinite, so this is more of an assertion of the programmer
  /// that this particular IEnumerable is finite.
  /// </summary>
  [<Extension>]
  let Finite (xs) = fseq xs

